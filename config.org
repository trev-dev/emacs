* Emacs Configuration
:PROPERTIES:
#+STARTUP: content
#+OPTIONS: toc:nil
:END:

The following configuration is an experimental Guix package. Do not use it. It's not ready yet.

Feel free to browse it and borrow/copy concepts about the configuration of Emacs, however.

To read more about how this configuration is supposed to work, see my [[* Configuration Strategy][config strategy]].

*Note:* /This document was generated using Emacs Org Mode by exporting [config.org](config.org)./ The programs this document creates are also generated by Emacs Org Mode by tangling the same file.

All references this document makes to itself are referring to it's Orgdown counterpart.

*Table of Contents*

#+TOC: headlines 4 local

** Configuration Strategy

The goal of my configuration strategy is to create a more re-producible "hardened" Emacs configuration with the help of the Guix package manager.

The long-term vision is to have a config that I am mostly happy with, that does not require much updating and is essentially a Guix package itself.

*** Tangling Files

This file is more than documentation. It is a literate program. With the power of Emacs org-mode, it can be tangled into several files that help facilitate the packaging of my init files as a Guix package. It also serves as a record of my Emacs dependencies.

This file produces the following files when tangled:

- .emacs.d/early-init.el
- .emacs.d/init.el
- emacs-d.scm

*** Configuring Packages

Since this init file is a the "build source" of a Guix package, it is assumed that all dependencies will already be installed before runtime is initiated.

For convenience, this file can be tangled to produce a Guile module, =emacs-d.scm=, which can serve as a useful reference for how to package the init configuration with its required dependencies. See [[Guix Package Module]] for more info.

The rest of the source code blocks in this file will be simple package configurations.

** Early Init
:PROPERTIES:
:header-args+: :tangle .emacs.d/early-init.el :mkdirp yes
:END:

This file is loaded before the initialization of emacs begins. It is sometimes helpful to pre-configure stuff in here.

*Note:* The ~:PROPERTIES:~ drawer in this section flags org-babel to make sure that the ~.emacs.d/~ directory exists using the =:mkdirp yes= argument.

#+begin_src elisp
;;; early-init.el --- Emacs early-init setup.
;;
;;; Commentary:
;; This file was generated using literate programming. Please see the config.org
;; file.
;;
;;; Code:
#+end_src

We want the garbage collector to have no limit during the init sequence.

#+begin_src elisp
(setq gc-cons-threshold most-positive-fixnum)
(setq package-enable-at-startup nil)
#+end_src

#+begin_src elisp
;;; early-init.el ends here
#+end_src

** Init File Headers
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el
:END:

This generates the top of the init file, which will set up the lexical scope and describe to Emacs what the file does.

#+begin_src elisp
;;; init.el --- Trev's Emacs config -*- lexical-binding: t -*-
;;
;; Copyright (C) 2022 Trevor Richards
;;
;; Author: Trevor Richards <trev@trevdev.ca>
;; Maintainer: Trevor Richards <trev@trevdev.ca>
;; URL: https://github.com/trev-dev/emacs
;; Created: 2nd August, 2022
;; Version: 1.0.0
;; License: GPL3
;;
;; This file is not a part of GNU Emacs.
;;
;; This program is free software: you can redistribute it and/or modify it under
;; the terms of the GNU General Public License as published by the Free Software
;; Foundation, either version 3 of the License, or (at your option) any later
;; version.
;;
;; This program is distributed in the hope that it will be useful, but
;; WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
;; FITNESS FOR A PARTICULAR PURPOSE.
;;
;; See the GNU General Public License for more details. You should have received
;; a copy of the GNU General Public License along with this program. If not, see
;; <https://www.gnu.org/licenses/>.
;;
;;; Commentary:
;; This program was generated using literate programming. See config.org for
;; details and documentation.
;;
;;; Code:
#+end_src

** General Settings
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el :comments link
:END:

Some general performance based improvements concerning large files, when to compile with the fancy new native-comp feature and reset the GC collection size after init.

#+begin_src elisp
(defvar emacs-startup-time (current-time)
  "When Emacs last initialized.")

(defun td/calculate-init-time (start-time)
  (float-time (time-subtract (current-time) start-time)))

(defun td/report-init-time ()
  "Prints the init time into the scratch buffer as a comment."
  (switch-to-buffer "*scratch*")
  (insert-before-markers
   (format ";; Init finished in %0.2f seconds; welcome to Emacs.\n"
           (td/calculate-init-time emacs-startup-time))))

(add-hook 'after-init-hook #'td/report-init-time)

(add-hook 'emacs-startup-hook
          (lambda ()
            (setq gc-cons-threshold (expt 2 23))))

(setq read-process-output-max (* 1024 1024))
(global-so-long-mode 1)
(setq comp-deferred-compilation t)
#+end_src

Clear out most of the GUI clutter, display relative line numbers, highlight the line I'm on, smaller left-only fringe, quick yes/no answers, some prog-mode QOL settings as well.

#+begin_src elisp
;; Interface
(scroll-bar-mode -1)
(tool-bar-mode -1)
(menu-bar-mode -1)
(blink-cursor-mode 1)
(setq display-line-numbers-type 'relative
      inhibit-startup-screen t
      initial-scratch-message ""
      history-length 25
      sentence-end-double-space nil
      visible-bell t)
(global-visual-line-mode 1)
(recentf-mode 1)
(save-place-mode 1)
(global-auto-revert-mode 1)
(fringe-mode '(4 . 0))
(defalias 'yes-or-no-p 'y-or-n-p)
(setq confirm-kill-emacs 'y-or-n-p)
#+end_src

Set up the dictionary and preferred browser.

#+begin_src elisp
;; Spelling
(setq ispell-personal-dictionary "~/.config/emacs/personal-dict.pwd"
      ispell-dictionary "en"
      ispell-alternate-dictionary (concat (getenv "HOME") "/Documents/wordlist"))

(define-key text-mode-map (kbd "C-c f") #'flyspell-mode)

;; Browser
(setq browse-url-generic-program "/usr/bin/firefox")
#+end_src

I hate seeing project folders get all cluttered up. Let's move autosaves and backups somewhere else.

#+begin_src elisp
;; Put autosave files (ie #foo#) and backup files (ie foo~) in ~/.emacs.d/.
(setq auto-save-file-name-transforms '((".*" "~/.emacs.d/autosaves/" t))
      backup-directory-alist '((".*" . "~/.emacs.d/backups/")))

;; create the autosave dir if necessary, since emacs won't.
(make-directory "~/.emacs.d/autosaves/" t)

(add-hook 'prog-mode-hook #'display-fill-column-indicator-mode)
#+end_src

Move custom variable settings to somewhere other that =init.el=.

#+begin_src elisp
(setq custom-file (locate-user-emacs-file "custom-vars.el"))
#+end_src

Start the pinentry service

#+begin_src elisp
(pinentry-start)
#+end_src

** Helper Functions
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el :comments link
:END:

Many people configure their emacs with the help of macros such as =use-package=. I prefer to keep my init lower-level and simple. I have written some simple functions that will make configuration less repetitive.

Using my own functions for the things I want or need keeps my overall package load smaller.

#+begin_src elisp
(defun td/bind-keys (conses &optional mode-map)
  "Bind several keybinds using a list of `CONSES'.
Binds will be global unless the optional `MODE-MAP' is specified."
  (dolist (combo conses)
    (if (or (consp mode-map) (keymapp mode-map))
        (define-key mode-map (kbd (car combo)) (cdr combo))
      (if mode-map (warn "Optional %s `MODE-MAP' was invalid: %s" (type-of mode-map) mode-map))
      (global-set-key (kbd (car combo)) (cdr combo)))))

(defun td/add-hooks (modes func)
  "Set several hooks from a list of `CONSES'.
Adds '-hook' onto the end of the symbols for brevity."
  (dolist (mode modes)
    (add-hook (intern (concat (symbol-name mode) "-hook")) func)))

(defun td/auto-mode (modes)
  "Add the `MODES' to the `auto-mode-alist'."
  (dolist (mode modes)
    (add-to-list 'auto-mode-alist mode)))

(defun td/filter-nil (seq)
  "Filter out nil items from sequence `SEQ'."
  (seq-filter #'(lambda (item) item) seq))

(defun td/is-file-buffer (buffer)
  "Test if a buffer belongs to a file on the system. Returns non-nil if it does."
  (let ((file (buffer-file-name buffer)))
    (when file
      (file-exists-p file))))
#+end_src

Create a mode for mapping high priority keybinds early on.

** Priority Mode
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el :comments link
:END:

Sometimes 3rd party packages like to take over my keyboard with their own keybinds. There are some keybinds that I prefer to always have access to without accidently triggering someone else's code first, then having to undo whatever that did, and use =M-x=.

With Priority mode, I am creating an "emulation layer". This is similar to what some popular modal editing packages do (such as evil-mode). It makes sure that when my ~priority-mode~ is active, the keybinds assigned to it will always take priority over other minor-mode bindings.

#+begin_src elisp
(define-minor-mode priority-mode
  "A minor mode for short-listing keybindings.
This will prevent other modes form overriding keys that I would prefer to
see bound."
  :init-value nil
  :global t
  :keymap (make-sparse-keymap))
(add-to-list 'emulation-mode-map-alists `((priority-mode . ,priority-mode-map)))
(priority-mode)
#+end_src

** Keybinds
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el :comments link
:END:

Change some of the built-in keybinds & bind some of the useful unbound functions.

#+begin_src elisp
(defun td/forward-chunk ()
  (interactive)
  (next-line 20))

(defun td/backward-chunk ()
  (interactive)
  (previous-line 20))

(td/bind-keys '(("M-j" . join-line)
                ("M-n" . td/forward-chunk)
                ("M-p" . td/backward-chunk)))
#+end_src

** Prog Mode
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el :comments link
:END:

A few settings that are useful in programming buffers that don't have much to do with 3rd party packages.

I am trying to respect the indent style of any file I come across, so I wrote some functions to help me with that.

#+begin_src elisp
(defun td/toggle-indent-tabs-mode ()
  "Toggle `indent-tabs-mode'."
  (interactive)
  (setq-local indent-tabs-mode (not indent-tabs-mode)))

(defun td/infer-indentation-style ()
  "Figure out whether or not we are indenting with tabs or spaces.
Set `indent-tabs-mode' accordingly."
  (let ((space-count (how-many "^  "))
        (tab-count (how-many "^\t")))
    (if (> space-count tab-count)
        (setq indent-tabs-mode nil))
    (if (> tab-count space-count)
        (setq indent-tabs-mode t))))
#+end_src

I need a setup hook that will trigger when prog-mode is activated.

#+begin_src elisp
(defun td/prog-mode-settings ()
  "A general set-up hook for prog-mode."
  (setq whitespace-style '(face tabs tab-mark trailing))
  (setq whitespace-display-mappings '((tab-mark 9 [9474 9] [92 9])))
  (custom-set-faces
   '(whitespace-tab ((t (:foreground "#636363")))))
  (setq-local fill-column 80)
  (setq-local show-trailing-whitespace t)
  (show-paren-mode t)
  (hs-minor-mode)
  (display-line-numbers-mode)
  (display-fill-column-indicator-mode)
  (electric-pair-local-mode)
  (td/infer-indentation-style)
  (whitespace-mode))
(add-hook 'prog-mode-hook 'td/prog-mode-settings)
#+end_src

I'd like to keep my tab style fixed at 2 spaces wherever possible. Specific programming modes can change this if they need to.

#+begin_src elisp
(setq indent-tabs-mode nil)
(setq standard-indent 2)
(setq backward-delete-char-untabify-method 'hungry)
(setq-default indent-tabs-mode nil)
(setq-default tab-width 2)
(setq-default evil-shift-width 2)
(setq-default electric-indent-inhibit t)
#+end_src

** Look & Feel
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el :comments link
:END:

*** Dired

I enjoy seeing icons next to file types. The =all-the-icons= and =all-the-icons-dired= package help facilitate this.

I also want to appropriate =gnus-dired-attach= for use with [[* Notmuch][notmuch]].

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-all-the-icons"
"emacs-all-the-icons-dired"
#+end_src

#+begin_src elisp
(setq dired-dwim-target t)
(with-eval-after-load 'dired
  (require 'all-the-icons)
  (setq all-the-icons-dired-monochrome nil)
  (add-hook
   'dired-mode-hook #'(lambda ()
                        (when (display-graphic-p)
                          (all-the-icons-dired-mode))
                        (dired-hide-details-mode)))

  (autoload 'gnus-dired-attach "gnus-dired.el"
    "Attach files from Dired to the current Message buffer." t)
  (define-key dired-mode-map (kbd "C-c C-m C-a") #'gnus-dired-attach))
#+end_src

*** COMMENT Doom Themes
Doom's themes are hard to beat. They're easy to install, highly customizable and hackable. Writing my own theme is easy.

#+begin_src elisp
(setq doom-themes-enable-bold t
      doom-themes-enable-italic t
      doom-themes-padded-modeline 1)
(load-theme 'doom-material-dark-devel t)
(enable-theme 'doom-material-dark-devel)
(doom-themes-org-config)
#+end_src

*** Custom Theme Devel

I've written my own theme called "tangonov".

#+begin_src elisp
(add-to-list 'custom-theme-load-path "~/Projects/tangonov-theme/")
(setq tangonov-selection-foregrounds nil)
(defun td/load-theme (frame)
  "Load the theme correctly for a `FRAME' if we're using emacsclient."
  (select-frame frame)
  (load-theme 'tangonov t))

(if (daemonp)
    (add-hook 'after-make-frame-functions #'td/load-theme)
  (load-theme 'tangonov t))
#+end_src

*** COMMENT Custom Theme

#+begin_src elisp :noweb-ref packages :tangle no
"emacs-tangonov-theme"
#+end_src
  
#+begin_src elisp
(load-theme 'tangonov t)
#+end_src

*** Font Setup

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"font-hack"
#+end_src

#+begin_src elisp
(set-language-environment "UTF-8")
(set-default-coding-systems 'utf-8)
(add-to-list 'default-frame-alist '(font . "Hack 12"))
#+end_src

** Modeline
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el :comments link
:END:

My custom modeline consists of many parts. The original goal was to create a light weight and simple modeline that displays the information that I want from a typical Emacs modeline in a way that I find appealing. I also hoped to never overflow in a 2 window view.

It has turned into something something else: A crazy exercise in learning how to optimize a modeline configuration that does silly things like render SVG icons.

The modeline config requires the =svg-lib= package.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-svg-lib"
#+end_src

*** Git status

With some effort I have been able to make a somewhat reliable, accurate status indicator for git projects that does not break my emacs.

#+begin_src elisp
(defvar-local tdm/git-status-indicator ""
  "The buffer's last known workspace status.")

(put 'tdm/git-status-indicator 'risky-local-variable t)

(defvar tdm/git-status-plist '(unregistered ("  ⁈" . (:foreground "#C792EA"))
                               edited ("  ±" . (:foreground "#82AAFF"))
                               up-to-date ("  ✔" . success)))

(defun tdm/git-create-indicator (buffer)
  "Create a git status indicator using a `BUFFER'."
  (let* ((status (vc-state-refresh buffer 'git))
         (icon-and-color (plist-get tdm/git-status-plist status))
         (branch (cond ((eq status 'unregistered) "untracked")
                       ((or vc-mode (progn (vc-refresh-state) vc-mode))
                        (substring vc-mode 5))
                       (t ""))))
    (propertize
     (concat
      (car icon-and-color) " " branch)
     'face (cdr icon-and-color))))

(defun tdm/git-cache-status (&optional frame)
  "Set local buffer's git cache status.
When used as a window hook, receive the `FRAME' as an argument."
  (let ((proj (project-current))
        (buff (buffer-file-name)))
    (when (and proj (member buff (project-files proj)))
      (setq tdm/git-status-indicator (tdm/git-create-indicator buff)))))

(defun tdm/git-cache-status-post-magit ()
  (let ((start-buffer (current-buffer)))
    (dolist (buff (seq-filter #'td/is-file-buffer
                              (project-buffers (project-current))))
      (switch-to-buffer buff)
      (setq tdm/git-status-indicator (tdm/git-create-indicator
                                      (buffer-file-name buff))))
    (switch-to-buffer start-buffer)))

(add-hook 'after-save-hook #'tdm/git-cache-status)
(add-to-list 'window-buffer-change-functions #'tdm/git-cache-status)
(add-hook 'magit-post-refresh-hook #'tdm/git-cache-status-post-magit)
#+end_src

*** Project indicator

#+begin_src elisp
(defcustom tdm/custom-project-name nil
  "A custom directory-local name for a project.el project."
  :type 'string)

(defvar-local tdm/project-mode-line-name ""
  "Project the current buffer belogns to.")

(put 'tdm/project-mode-line-name 'risky-local-variable t)

(defun tdm/project ()
  "Display the current project name, or path."
  (let ((pc (project-current))
        (pname-not-set (string= tdm/project-mode-line-name "")))
    (if (and pc pname-not-set)
        (setq tdm/project-mode-line-name
              (format-mode-line
               (list
                `(:propertize ,(or tdm/custom-project-name
                                   (file-name-nondirectory
                                    (directory-file-name
                                     (project-root pc))))
                              face success
                              help-echo "Switch project"
                              mouse-face (:box 1)
                              local-map ,(make-mode-line-mouse-map
                                          'mouse-1 #'project-switch-project))
                '(:propertize ":" face (:inherit font-lock-comment-face)))))
      tdm/project-mode-line-name)))
#+end_src

*** Modal mode indicators

#+begin_src elisp
(defun tdm/modal-face (str base)
  (propertize str 'face
              `(:inherit ,base :weight bold :height 0.9)))

(defvar tdm/custom-meow-states `((normal . ,(tdm/modal-face
                                             "<N>" '(:foreground "#FFCA41")))
                                 (motion . ,(tdm/modal-face
                                             "<M>" '(:foreground "#82AAFF")))
                                 (keypad . ,(tdm/modal-face
                                             "<K>" '(:foreground "#89DDFF")))
                                 (insert . ,(tdm/modal-face
                                             "<I>" '(:foreground "#C792EA")))
                                 (beacon . ,(tdm/modal-face
                                             "<B>" '(:foreground "#FF7B85")))))

(defvar tdm/evil-states `((normal . ,(tdm/modal-face
                                      "<N>" '(:foreground "#FFCA41")))
                          (motion . ,(tdm/modal-face
                                      "<M>" '(:foreground "#82AAFF")))
                          (operator . ,(tdm/modal-face
                                        "<O>" '(:foreground "#89DDFF")))
                          (insert . ,(tdm/modal-face
                                      "<I>" '(:foreground "#ABDC88")))
                          (visual . ,(tdm/modal-face
                                       "<V>" '(:foreground "#FF996B")))
                          (replace . ,(tdm/modal-face
                                       "<R>" '(:foreground "#FF7B85")))
                          (emacs . ,(tdm/modal-face
                                     "<E>" '(:foreground "#C792EA")))))

(defun tdm/meow-state ()
  "Retrieve the meow-state for the mode-line."
  (when (featurep 'meow)
    (concat (alist-get (meow--current-state) tdm/custom-meow-states)
            " ")))

(defun tdm/evil-state ()
  "Get the evil state for the mode-line."
  (when (featurep 'evil)
    (concat (alist-get evil-state tdm/evil-states)
            " ")))
#+end_src

*** God mode indicator

This is where we use =svg-lib= to bring the thunder.

#+begin_src elisp
(defvar tdm/god-mode-icon
  (propertize "<G>" 'face '(:foreground "#FFCA41" :weight bold))
  "The hammer of the gods, but only if you are worthy.")

(defvar-local tdm/god-mode-indicator--cached ""
  "The cached state of the `god-local-mode' indicator for the mode-line.")

(put 'tdm/god-mode-indicator--cached 'risky-local-variable t)

(defun tdm/god-mode-icon--make-icon ()
  "Produce the hammer of the gods."
  (propertize
   "  " 'display (when (functionp 'svg-lib-icon)
                   (svg-lib-icon
                    "mjolnir"
                    `(:collection "local"
                      :stroke 0
                      :padding 0
                      :width 20
                      :foreground ,(face-foreground 'warning)
                      :background ,(face-background 'mode-line))))))

(defun tdm/god-mode-icon--set-icon ()
  "Set the `tdm/god-mode-icon' as an svg icon in graphical displays."
  (when (display-graphic-p)
    (setq tdm/god-mode-icon (tdm/god-mode-icon--make-icon))))

(defun tdm/god-mode-setup-icon ()
  "Set up the `tdm/god-mode-icon' as late as possible in the init process.

The reasoning for this is because if the window's not ready to go, an SVG
icon renders incorrectly."
  (tdm/god-mode-icon--set-icon)
  (tdm/god-mode-indicator--update-cached))

(defun tdm/god-mode-indicator--update-cached ()
  "A hook function for setting `tdm/god-mode-indicator'."
  (setq tdm/god-mode-indicator--cached
        (format
         "%s" (if (bound-and-true-p god-local-mode)
                  tdm/god-mode-icon
                ""))))

(defun tdm/god-mode-indicator ()
  "Display `td/god-mode-indicator--cached' in the mode-line."
  tdm/god-mode-indicator--cached)

(with-eval-after-load 'god-mode
  (defvar svg-lib-icon-collections) ; Satisfy compiler
  (require 'svg-lib)

  (add-to-list 'svg-lib-icon-collections
               (cons "local" "file:///home/trevdev/.config/emacs/%s.svg"))
  (tdm/god-mode-setup-icon)
  (add-hook 'god-local-mode-hook #'tdm/god-mode-indicator--update-cached))
#+end_src

*** Buffer related info

Numerous functions to help appreciate what's going on with a buffer inclding status flags for read-only, modified or in a client frame.

#+begin_src elisp
(defun tdm/status-flag (on face)
  "Produce a status flag based on some `PRED'icate test and give it a `FACE'."
  (format "%s" (if on
                   (propertize "▰" 'face `(:inherit ,face :weight bold))
                 "-")))

(defun tdm/line-number-indicator--update ()
  "Display the mode-line buffer position."
  (setq tdm/line-number-indicator
        (if line-number-mode (list "  %l:%c") "")))

(defvar-local tdm/line-number-indicator (tdm/line-number-indicator--update)
  "Display buffer position in the mode-line.")

(add-hook 'line-number-mode-hook #'tdm/line-number-indicator--update)

(defun tdm/buffer-size--update ()
  "Update the `tdm/buffer-size' mode-line variable."
  (setq tdm/buffer-size
        (if size-indication-mode
            '(:propertize " (%I)" :face '(:inherit font-lock-comment-face))
          "")))

(defvar-local tdm/buffer-size (tdm/buffer-size--update)
  "Display the buffer size in the mode-line.")

(add-hook 'size-indication-mode-hook #'tdm/buffer-size--update)
#+end_src

*** Various other package indicators

Flycheck Flymake, the built in misc info, etc.

#+begin_src elisp
(defun tdm/flycheck ()
  "Get the flycheck status for the buffer, if LSP mode is not doing so."
  (when (and (bound-and-true-p flycheck-mode)
             (not (bound-and-true-p lsp-mode)))
    (let* ((errlist (flycheck-count-errors flycheck-current-errors))
           (warnings (alist-get 'warning errlist))
           (errors (alist-get 'error errlist)))
      (concat
       (when warnings
         (propertize (format "  %s%s"
                             warnings (if errors "/" ""))
                     'face 'warning))
       (when errors
         (propertize (format
                      "%s%s" (if warnings "" "  ") errors)
                     'face 'error))))))

(defun tdm/flymake ()
  "Display the flymake status for the buffer."
  (when (bound-and-true-p flymake-mode) " "
    flymake-mode-line-title
    flymake-mode-line-exception
    flymake-mode-line-counters))

(defun tdm/misc ()
  "Get a trimmed version of the `mode-line-misc-info'."
  (let ((info (format-mode-line mode-line-misc-info)))
    (unless (string= info "")
      (list "  " (string-trim info)))))

(defun tdm/macro-indicator ()
  "Indicate when a macro is being recorded in the mode-line."
  (when defining-kbd-macro
    (format "%s" (propertize
                  "λ" 'face '(:inherit bold :foreground "#C792EA")))))

(defun tdm/anzu-indicator ()
  (when (bound-and-true-p anzu-mode)
    (concat " " (anzu--update-mode-line))))
#+end_src

*** Render a split-view mode-line

This is not a very efficient way to render a modeline but it's the best way I could figure out how to make the columns. On the left side are the stats/flags for the buffer itself. On the right are all of the major/minor mode features

#+begin_src elisp
(defun tdm/split-format (left right)
  "Format a mode-line with a `LEFT' and `RIGHT' justified list of elements.
The modeline should fit the `window-width' with space between the lists."
  (let ((reserve (length right)))
    (concat left
            " "
            (propertize " "
                        'display
                        `((space :align-to
                                 (- right (- 0 right-margin) ,reserve))))
            right)))

(setq-default mode-line-format
              '((:eval
                 (tdm/split-format
                  ;; Left
                  (format-mode-line
                   '(" "
                     (:eval (tdm/meow-state))
                     (:eval (tdm/evil-state))
                     (:eval (tdm/status-flag buffer-read-only 'error))
                     (:eval (tdm/status-flag (buffer-modified-p) 'warning))
                     (:eval (if (not (eq
                                      (format-mode-line mode-line-client)
                                      ""))
                                (tdm/status-flag t '(:foreground "#C792EA"))
                              ""))
                     " "
                     (:eval (tdm/project))
                     mode-line-buffer-identification
                     tdm/line-number-indicator
                     (:eval (tdm/anzu-indicator))
                     tdm/buffer-size
                     (:propertize " %p%%" face (:inherit font-lock-comment-face))))
                  ;; Right
                  (format-mode-line
                   '((:eval (tdm/god-mode-indicator))
                     (:eval (tdm/macro-indicator))
                     (:eval (tdm/flycheck))
                     tdm/git-status-indicator
                     (:eval (tdm/misc))
                     "  "
                     mode-line-modes))))))
#+END_SRC

*** Diminish the minor-mode-alist

The =diminish= package reduces the output from the =minor-mode-alist= in the minibuffer. Due to how lazy-loading works, we want to make sure we have diminish early on.

This greatly reduces noise in the mode-line while being aware of important contextual minor-modes.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-diminish"
#+end_src

#+begin_src elisp
(defun tdm/diminish-lsp-lighter ()
  "Display the LSP status in the `mode-line-modes'."
  (let* ((lsp-up lsp--buffer-workspaces)
         (color (if lsp-up '(:inherit success :weight bold)
                  '(:inherit warning :weight bold))))
    `(:propertize " LSP" face ,color)))

(dolist (mode '(("company" 'company-mode)
                ("hideshow" 'hs-minor-mode)
                ("undo-tree" 'undo-tree-mode)
                ("whitespace" 'whitespace-mode)
                ("yasnippet" 'yas-minor-mode)
                ("which-key" 'which-key-mode)
                ("org-indent" 'org-indent-mode)
                ("simple" 'visual-line-mode)
                ("eldoc" 'eldoc-mode)
                ("evil-org" 'evil-org-mode)
                ("flycheck" 'flycheck-mode)
                ("flymake" 'flymake-mode)
                ("tree-sitter" 'tree-sitter-mode "TS")
                ("lsp-mode" 'lsp-mode '(:eval (tdm/diminish-lsp-lighter)))
                ("god-mode" 'god-local-mode)
                ("beacon" 'beacon-mode)
                ("evil-goggles" 'evil-goggles-mode)
                ("evil-commentary" 'evil-commentary-mode)
                ("goggles" 'goggles-mode)))
  (eval-after-load (car mode)
    `(diminish ,(cadr mode) ,(caddr mode))))

(diminish 'defining-kbd-macro)

(with-eval-after-load 'meow
  (dolist (mode (list 'meow-normal-mode
                      'meow-insert-mode
                      'meow-motion-mode
                      'meow-keypad-mode
                      'meow-beacon-mode))
    (diminish mode)))
#+end_src

** Utility Packages
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el :comments link
:END:

Configurations for packages that enrich the Emacs experience. Some packages are internal, many are external.

*** Avy

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-avy"
#+end_src

#+begin_src elisp
(define-key priority-mode-map (kbd "C-:") #'avy-goto-char-timer)
(define-key isearch-mode-map (kbd "C-:") #'avy-isearch)
(avy-setup-default)
#+end_src

*** Anzu

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-anzu"
#+end_src

#+begin_src elisp
(with-eval-after-load 'isearch
  (require 'anzu)
  (global-anzu-mode +1)

  (setq anzu-mode-lighter ""
        anzu-deactivate-region t
        anzu-search-threshold 1000
        anzu-replace-threshold 50
        anzu-cons-mode-line-p nil)
  (global-set-key [remap query-replace] #'anzu-query-replace)
  (global-set-key [remap query-replace-regexp] #'anzu-query-replace-regexp))
#+end_src

*** COMMENT Awesome Tray

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-svg-lib"
#+end_src

#+begin_src elisp
(add-to-list 'load-path (expand-file-name "~/Projects/awesome-tray"))
(require 'awesome-tray)
(require 'svg-lib)

(add-to-list 'svg-lib-icon-collections
             (cons "local" "file:///home/trevdev/.config/emacs/%s.svg"))

(defvar tdm/god-mode-icon
  (propertize
   "  " 'display (svg-lib-icon
                   "mjolnir"
                   `(:collection "local"
                     :stroke 0
                     :padding 0
                     :foreground ,(face-foreground 'warning))))
  "The hammer of the gods.")

(defun awesome-tray-god-mode-indicator ()
  "A god-mode indicator for awesome-tray."
  (if (bound-and-true-p god-local-mode)
      tdm/god-mode-icon
    ""))

(add-to-list 'awesome-tray-module-alist
             '("god-mode" . (awesome-tray-god-mode-indicator)))

(setq awesome-tray-active-modules '("god-mode"
                                    "anzu"
                                    "git"
                                    "buffer-name"
                                    "buffer-read-only"
                                    "clock"
                                    "mode-name"
                                    "location")
      awesome-tray-info-padding-right 2)
(awesome-tray-mode 1)
#+end_src

*** Completions
A combination of packages to enhance completions.

**** Icomplete mode

#+begin_src elisp
(icomplete-vertical-mode 1)
(setq icomplete-show-matches-on-no-input t)

(defun td/toggle-flex-completion ()
  "Toggle flex completion."
  (interactive)
  (if (member 'flex completion-styles)
      (progn (message "Flex Off")
             (setq-local completion-styles (remove 'flex completion-styles)))
    (message "Flex On")
    (setq-local completion-styles `(flex ,@completion-styles))))

(td/bind-keys '(("C-n"        . icomplete-forward-completions)
                ("C-p"        . icomplete-backward-completions)
                ("S-<return>" . icomplete-force-complete-and-exit)
                ("C-c f"      . td/toggle-flex-completion))
              icomplete-minibuffer-map)
#+end_src

**** Corfu & Cape

#+begin_src scheme packages :noweb-ref packages :tangle no :exports none
"emacs-corfu"
"emacs-corfu-terminal"
"emacs-cape"
#+end_src

#+begin_src elisp
(defun corfu/start ()
  (require 'corfu)
  (setq corfu-cycle t
        corfu-auto t
        corfu-auto-prefix 3
        corfu-auto-delay 0.3)

  (defun corfu-enable-in-minibuffer ()
  "Enable Corfu in the minibuffer if `completion-at-point' is bound."
  (when (where-is-internal #'completion-at-point (list (current-local-map)))
    ;; (setq-local corfu-auto nil) Enable/disable auto completion
    (corfu-mode 1)))

  (add-hook 'minibuffer-setup-hook #'corfu-enable-in-minibuffer)

  (global-corfu-mode 1)

  (unless (display-graphic-p)
    (corfu-terminal-mode 1))

  (with-eval-after-load 'god-mode
    (add-hook 'god-local-mode-hook #'corfu-quit))

  (require 'cape)
  (add-to-list 'completion-at-point-functions #'cape-file)
  (add-to-list 'completion-at-point-functions #'cape-dabbrev)
  (add-hook 'text-mode-hook
            #'(lambda ()
                (add-to-list 'completion-at-point-functions #'cape-ispell)))

  ;; Silence the pcomplete capf, no errors or messages!
  ;; Important for corfu
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-silent)

  ;; Ensure that pcomplete does not write to the buffer
  ;; and behaves as a pure `completion-at-point-function'.
  (advice-add 'pcomplete-completions-at-point :around #'cape-wrap-purify)
  (add-hook 'eshell-mode-hook
            (lambda () (setq-local corfu-quit-at-boundary t
                                   corfu-quit-no-match t
                                   corfu-auto nil)
              (corfu-mode))))

(add-hook 'after-init-hook #'corfu/start)
#+end_src

**** Orderless

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-orderless"
#+end_src

#+begin_src elisp
(with-eval-after-load 'icomplete
  (require 'orderless)
  (setq completion-styles '(orderless basic)
        completion-category-overrides
        '((file (styles basic partial-completion)))))
#+end_src

**** Savehist

Save history for Vertico to look at later.

#+begin_src elisp
(savehist-mode)
#+end_src

*** Denote

Denote is Protesilaos's solution for note-taking. It's dependency free, makes good use of the built-in Emacs conventions and it keeps your notes highly portable.

For more information, visit the [[https://protesilaos.com/emacs/denote][denote manual]].

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-denote"
#+end_src

#+begin_src elisp
(setq denote-directory (expand-file-name "~/Org/denote/")
      denote-file-type 'org
      denote-known-keywords '("journal" "programming" "foss" "idea")
      denote-prompts '(title keywords)
      denote-link-fontify-backlinks t)

(defun denote/journal ()
  "Create an entry tagged 'journal', while prompting for a title."
  (interactive)
  (denote
   (denote--title-prompt)
   '("journal")))

(defun denote/jump-to-denote-directory ()
  "Open dired in the `denote-directory'."
  (interactive)
  (dired denote-directory))

(defvar denote/keymap
  (let ((m (make-sparse-keymap)))
    (td/bind-keys '(("n" . denote)
                    ("j" . denote/journal)
                    ("t" . denote-template)
                    ("i" . denote-link)
                    ("I" . denote-link-add-links)
                    ("f" . denote-link-find-file)
                    ("b" . denote-link-backlinks)
                    ("r" . denote-rename-file)
                    ("R" . denote-rename-file-using-front-matter)
                    ("j"   . denote/jump-to-denote-directory)
                    ("l"   . denote-link))
                  m)
    m))

(global-set-key (kbd "C-c n") denote/keymap)

(with-eval-after-load 'dired
    (td/bind-keys '(("C-c n i" . denote-link-dired-marked-notes)
                    ("C-c n r" . denote-dired-rename-marked-files)
                    ("C-c n R" .
                     denote-dired-rename-marked-files-using-front-matter))
                  dired-mode-map))

(with-eval-after-load 'org-capture
  (setq denote-org-capture-specifiers "%l\n%i\n%?")
  (add-to-list 'org-capture-templates
               '("n" "New note (with denote.el)" plain
                 (file denote-last-path)
                 #'denote-org-capture
                 :no-save t
                 :immediate-finish nil
                 :kill-buffer t
                 :jump-to-captured t)))

(add-hook 'find-file-hook #'denote-link-buttonize-buffer)
(add-hook 'dired-mode-hook #'denote-dired-mode)
#+end_src

*** Docker

Docker support is provided by:

- emacs-docker
- emacs-dockerfile-mode
- emacs-docker-compose-mode

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-docker"
"emacs-dockerfile-mode"
"emacs-docker-compose-mode"
#+end_src

*** Diff-hl

Show me the diffs in the fringe!

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-diff-hl"
#+end_src

#+begin_src elisp
(setq diff-hl-show-staged-changes nil)
(global-diff-hl-mode)
(with-eval-after-load 'magit
  (add-hook 'magit-pre-refresh-hook 'diff-hl-magit-pre-refresh)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh))
#+end_src

*** Ediff

I enjoy using tiling window managers. It serves me better to avoid having a separate, floating window for ediff.

#+begin_src elisp
(setq ediff-window-setup-function 'ediff-setup-windows-plain)
#+end_src

*** Elfeed

RSS Reader :D

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-elfeed"
#+end_src

#+begin_src elisp
(global-set-key (kbd "<f6>") #'elfeed)
#+end_src

*** EMMS

Emacs Multi-Media System

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-emms"
#+end_src

#+begin_src elisp
(defun td/start-emms ()
  "Start up emms."
  (interactive)
  (require 'emms-setup)
  (require 'emms-player-mpd)

  (emms-all)

  (setq emms-player-mpd-server-port "6600"
        emms-player-mpd-music-directory "~/Music"
        emms-player-mpd-server-name "localhost")

  (add-to-list 'emms-player-list 'emms-player-mpd)
  (add-to-list 'emms-info-functions 'emms-info-mpd)

  (emms-mode-line-mode -1)
  (emms-player-mpd-connect)

  (defvar emms-keymap
    (let ((m (make-sparse-keymap)))
      (td/bind-keys '(("e" . emms)
                      ("B" . emms-smart-browse)
                      ("P" . emms-pause)
                      ("n" . emms-next)
                      ("p" . emms-previous)
                      ("f" . emms-seek-forward)
                      ("b" . emms-seek-backward)
                      ("s" . emms-start)
                      ("k" . emms-stop))
                    m)
      m)
    "Keybindings for EMMS.")
  (fset 'emms-keymap emms-keymap)
  (global-set-key (kbd "C-c e") #'emms-keymap)
  (emms-librefm-scrobbler-enable))
#+end_src

*** Surround

My attempt at writing a quick replacement for "vim surround". There are better solutions out there, but when they're unpredictable, I don't want to figure out why.

This is a "dumb" solution. It just seeks backward for the start of a pair, then matches the surround with a forward sexp. If it's called with a neg-arg (eg: ~(surround -1)~) it will scan forward first and look back. If the point is not inside the bounds of a resulting backward scan, we fall back to forward.

Ideally if the point is not inside the bounds of a found sexp, I should be scanning recursively in the same direction until it does. Maybe I'll implement this later.

When a pair is not in ~surround-pairs~, it will fall-back to symmetrical pairs (a pair of the same char). When this happens, scanning forward, or backward, makes no difference.

It currently doesn't care about the scope of the scan, either, and doesn't care if the backward or forward sexp is 100 lines elsewhere.

I should refine this.

#+begin_src elisp
(defvar surround-pairs '(("{" . "}")
                         ("(" . ")")
                         ("[" . "]")
                         ("<" . ">"))
  "A list of asymmetric pairs for `surround' to respect.")

(defun surround--seek-outer-boundary (start left pair count)
  "Seek out the boundary of an outside `PAIR' from the `START'.
If `LEFT' is non-nil, seek left. Otherwise, seek right."
  (let* ((search (if left #'search-backward #'search-forward))
         (ch-match (if left (car pair) (cdr pair)))
         (ch-skip  (if left (cdr pair) (car pair)))
         (sym (eq ch-skip ch-match))
         (case-fold-search nil))
    (save-excursion
      (if sym
          (apply search (list ch-match nil t count))
        (let* ((match (apply search (list ch-match nil t count)))
               (mid (push-mark start t t))
               (imbalance (count-matches (regexp-quote ch-skip)
                                         (region-beginning)
                                         (region-end)))
               (mcount (count-matches (regexp-quote ch-match)
                                      (region-beginning)
                                      (region-end))))
          (if (and (>= imbalance mcount) match)
              (surround--seek-outer-boundary start left pair
                                             (+ (- imbalance mcount) 1))
            (deactivate-mark)
            match))))))

(defun surround--seek-bounds (pair)
  "Find the bounds of a surrounding `PAIR' around the point."
  (let ((bounds (cons (surround--seek-outer-boundary (point) t pair 1)
                      (surround--seek-outer-boundary (point) nil pair 1))))
    (if (and (car bounds) (cdr bounds))
        bounds
      (user-error (format "No surrounding pair: %s" pair)))))

(defun surround--add-pair (bounds pair)
  "Add an arbitrary surrounding `PAIR' of chars to a `BOUNDS'."
  (save-excursion
    (goto-char (car bounds))
    (insert (car pair))
    (goto-char (+ (cdr bounds) 1))
    (insert (cdr pair))))

(defun surround--delete-pair (bounds)
  "Delete a surrounding pair outside the `BOUNDS' a range of positions."
  (save-excursion
    (goto-char (- (cdr bounds) 1))
    (delete-char 1)
    (goto-char (car bounds))
    (delete-char 1)))

(defun surround--change-pair (bounds)
  "Swap out an exisiting `PAIR' outside of `BOUNDS'."
  (let* ((to-what (char-to-string (read-char (message "To new pair: "))))
         (new-pair (or (assoc to-what surround-pairs)
                       (rassoc to-what surround-pairs)
                       (cons to-what to-what))))
    (surround--delete-pair bounds)
    (surround--add-pair (cons (car bounds) (- (cdr bounds) )) new-pair)))

(defun surround (neg)
  "Add surrounding pairs to a region, or change/delete an existing pair.
Inspired by vim-surround. Scans forward. Use `NEG'-arg to scan backward
for pair."
  (interactive "p")
  (let* ((reverse (< neg 0))
         (case-fold-search nil)
         (method (if (and (region-active-p)
                          (not (eq (region-beginning) (region-end))))
                     ?a
                   (read-char-choice "(c)hange or (d)elete pair? " '(?c ?d))))
         (target (char-to-string (read-char (message "Pair:"))))
         (pair (or (assoc target surround-pairs)
                   (rassoc target surround-pairs)
                   (cons target target)))
         (bounds (or (and
                      (region-active-p)
                      (car (region-bounds)))
                     (surround--seek-bounds pair))))
    (cond ((eq method ?a) (surround--add-pair bounds pair))
          ((eq method ?c) (surround--change-pair bounds))
          ((eq method ?d) (surround--delete-pair bounds)))))

(global-set-key (kbd "C-S-s") #'surround)
#+end_src

*** Ement

A Matrix client for Emacs.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-ement"
"pantalaimon"
#+end_src

#+begin_src elisp
(defun td/matrix-connect ()
  "Connect to Matrix via Ement & Pantalaimon."
  (interactive)
  (ement-connect
   :user-id "@trevdev:matrix.org"
   :password (password-store-get "Personal/matrix.org")
   :uri-prefix "http://localhost:8009"))
#+end_src

*** ERC

#+begin_src elisp
(setq erc-autojoin-channels-alist
      '(("Libera.Chat" "#emacs" "#guix" "#systemcrafters" "#stumpwm")))

(defun td/launch-erc ()
  (interactive)
  (erc-tls :server "irc.libera.chat"
                             :port 7000
                             :nick "trevdev"
                             :password (password-store-get
                                        "Biz/libera.chat")))
#+end_src

*** Eshell

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-eshell-syntax-highlighting"
#+end_src

#+begin_src elisp
(defun td/eshell-extras ()
  "Start extra features for eshell-mode"
  (eshell-syntax-highlighting-mode))

(add-hook 'eshell-mode-hook #'td/eshell-extras)
#+end_src

*** COMMENT Evil

#+begin_src elisp :noweb-ref packages :tangle no
"emacs-evil"
#+end_src

**** Keybinds

Evil requires a lot of key re-binding in order to get going. You may still find yourself using =M-x= from time to time, looking for some keybind and discovering it's something like =C-c C-x M-o q r s= and think "yeah, that's easy!" Just kidding. You'll want to create mode-specific (or global) leader, normal or motion mapping.

#+begin_src elisp
(defun td/evil-bind-keys ()
  "Create some extra evil bindings."
  (evil-set-leader 'normal (kbd "SPC"))
  ;; Avy
  (evil-define-key 'normal 'global (kbd "<leader>;") 'avy-goto-char-timer)
  ;; General
  (evil-define-key 'normal 'global (kbd "<leader>ff") 'find-file)
  (evil-define-key 'normal 'global (kbd "<leader>fg") 'project-find-file)
  (evil-define-key 'normal 'global (kbd "<leader>b") 'consult-buffer)
  (evil-define-key 'normal 'global (kbd "<leader>x") 'execute-extended-command)
  ;; LSP
  (evil-define-key 'normal lsp-mode-map (kbd "K") 'lsp-ui-doc-glance)
  ;; Org
  (evil-define-key 'normal org-mode-map (kbd "<leader>ci") 'org-clock-in)
  (evil-define-key 'normal org-mode-map (kbd "<leader>co") 'org-clock-out)
  (evil-define-key 'normal org-mode-map (kbd "<leader>'") 'org-edit-special)
  (evil-define-key 'normal org-src-mode-map (kbd "<leader>'") 'org-edit-special)
  (evil-define-key 'normal 'global (kbd "<leader>a") 'org-agenda)
  (evil-define-key 'normal 'global (kbd "<leader>i") 'td/eldoc-box-help)
  (evil-define-key 'normal 'global (kbd "<leader>cg") 'org-clock-goto)
  ;; Magit
  (evil-define-key 'normal 'global (kbd "gs") 'magit))
#+end_src

**** Extending Evil Mode

There are a lot of packages that make Evil better by extending it. Thankfully they are easy to set up.

The following sub-headlines will be tangled into this block:

#+begin_src elisp :tangle .emacs.d/init.el :noweb yes
(with-eval-after-load 'evil
  <<after-load-evil>>)
#+end_src

***** evil-lion

Evil-lion is for making emac's built-in =align= function more "evil" friendly the motion =gl= (align right) or =gL= (align left). For example, =glp.= would left align all elements in a paragraph on a period character.

#+begin_src elisp :noweb-ref packages :tangle no :exports none
"emacs-evil-lion"
#+end_src

#+begin_src elisp :noweb-ref after-load-evil :tangle no :exports none
(evil-lion-mode)
#+end_src

***** evil-matchit

The essential pair matching plugin for vim ported to evil-mode.

#+begin_src elisp :noweb-ref packages :tangle no :exports none
"emacs-evil-matchit"
#+end_src

#+begin_src elisp :noweb-ref after-load-evil :tangle no :exports none
(global-evil-matchit-mode 1)
#+end_src

***** evil-surround

The essential pair swapping plugin by the venerable Tim Pope ported to evil-mode.

#+begin_src elisp :noweb-ref packages :tangle no :exports none
"emacs-evil-surround"
#+end_src

#+begin_src elisp :noweb-ref after-load-evil :tangle no :exports none
(global-evil-surround-mode 1)
#+end_src

***** COMMENT evil-snipe

#+begin_src elisp :noweb-ref packages :tangle no :exports none
"emacs-evil-snipe"
#+end_src

#+begin_src elisp :noweb-ref after-load-evil :tangle no :exports none
(evil-snipe-mode 1)
(evil-snipe-override-mode t)
(add-hook 'magit-mode-hook #'turn-off-evil-snipe-override-mode)
#+end_src

***** evil-exchange

Be able to swap two motion-selected areas with the =gx= motion.

#+begin_src elisp :noweb-ref packages :tangle no :exports none
"emacs-evil-exchange"
#+end_src

#+begin_src elisp :noweb-ref after-load-evil :tangle no :exports none
(evil-exchange-install)
#+end_src

***** evil-multiedit

Multiedit is sorta like the venerable multiple cursors plugin, only it's vimish and frankly, not as good. It's still better than writing macros for everything.

#+begin_src elisp :noweb-ref packages :tangle no :exports none
"emacs-evil-multiedit"
#+end_src

Unfortunately, ~evil-multiedit-default-keybinds~ overrides common meta functions like delete-word (M-d). Theoretically, we would not be using these with evil anyway.

#+begin_src elisp :noweb-ref after-load-evil :tangle no :exports none
(require 'evil-multiedit)
(evil-multiedit-default-keybinds)
#+end_src

***** evil-commentary

Make commenting code motion-friendly with the =gc= motion.

#+begin_src elisp :noweb-ref packages :tangle no :exports none
"emacs-evil-commentary"
#+end_src

#+begin_src elisp :noweb-ref after-load-evil :tangle no :exports none
(add-hook 'prog-mode-hook #'evil-commentary-mode)
#+end_src

***** COMMENT evil-collection

This package is _massive_. It is a collaborative, community effort to bring sane evil keybinds to as many major modes as possible. Its goal is to keep things consistent and as predictable as possible.

It does add a lot of package bloat, however. Without it, many major modes dump you into "Emacs mode". If you're used to, and are okay with the occasional Emacs only interface, you might wanna skip this one.i

#+begin_src elisp :noweb-ref packages :tangle no :exports none
"emacs-evil-collection"
#+end_src

#+begin_src elisp :noweb-ref after-load-evil :tangle no :exports none
(evil-collection-init)
#+end_src

***** COMMENT evil-org

Evil-org /greatly/ improves the org-mode experience in evil-mode Emacs.

#+begin_src elisp :noweb-ref packages :tangle no :exports none
"emacs-evil-org"
#+end_src

#+begin_src elisp :noweb-ref after-load-evil :tangle no :exports none
(with-eval-after-load 'org
  (require 'evil-org)
  (require 'evil-org-agenda)
  (evil-org-agenda-set-keys)
  (add-hook 'org-mode-hook #'evil-org-mode))
#+end_src

**** Apply Evil Configurations

Here apply our evil configurations and set up our hooks.

#+begin_src elisp
(defun evil/start ()
  "Start evil-mode."
  (setq evil-want-C-u-scroll t)
  (require 'evil)
  (setq evil-visual-state-cursor 'hbar
        evil-insert-state-cursor '(bar . 4))
  (customize-save-variable 'evil-undo-system 'undo-redo)
  (td/evil-bind-keys)
  (evil-mode 1))

(add-hook 'after-init-hook #'evil/start)
#+end_src

*** Expand Region

It just makes selecting text between sexps easy.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-expand-region"
#+end_src

#+begin_src elisp
(defun td/setup-expand-region ()
  (require 'expand-region)
  (td/bind-keys '(("C-=" . er/expand-region)))
  (defvar er/keymap
    (let ((map (make-sparse-keymap "er/objects")))
      (td/bind-keys '(("w"   . er/mark-word)
                      ("W"   . er/mark-symbol)
                      ("s"   . er/mark-sentence)
                      ("p"   . er/mark-paragraph)
                      ("e"   . er/mark-email)
                      ("d"   . er/mark-defun)
                      ("u"   . er/mark-url)
                      ("o p" . er/mark-outside-pairs)
                      ("i p" . er/mark-inside-pairs)
                      ("o s" . er/mark-outside-quotes)
                      ("i s" . er/mark-inside-quotes)
                      ("o e" . er/mark-org-element)
                      ("o E" . er/mark-org-element-parent))
                    map)
      map)
    "A keymap for quickly calling expand region functions.
\\{er/keymap}")
  (fset 'er/keymap er/keymap)
  (define-key priority-mode-map (kbd "C-,") er/keymap))

(add-hook 'after-init-hook #'td/setup-expand-region)
#+end_src

*** God Mode

God mode is an amazing package. It automatically translates key-chords into single-key bindings and toggled modifiers.

Because it has its own keymap, I can add utility functions to god-mode. This turns it into sort of a pseudo-modal editing mode. However, unlike other modal packages, it does not require as much key re-binding, thanks to key-chord translation.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-god-mode"
#+end_src

**** Functions

These functions enhance editing while allowing me to "drop out" of god-mode in useful ways.

#+begin_src elisp
(defun god/exit-god-local (&rest args)
  (god-local-mode -1))

(defun god/eol-insert ()
  "Move the cursor to the end-of-line and exit god mode."
  (interactive)
  (end-of-line)
  (god/exit-god-local))

(defun god/boi-insert ()
  "Move the cursor `back-to-indentation' and exit god mode."
  (interactive)
  (back-to-indentation)
  (god/exit-god-local))

(defun god/change ()
  "Kill char/region and exit god mode."
  (interactive)
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (zap-to-char 1 (char-after)))
  (god/exit-god-local))

(defun god/backward-symbol (num)
  "Move backward `NUM' symbols."
  (interactive "^p")
  (forward-symbol (- 0 (or (when (natnump num) num) 1))))

(defun god/open-above ()
  "Open a new line above the current line, put the point there."
  (interactive)
  (beginning-of-line)
  (split-line)
  (god/exit-god-local))

(defun god/open-below ()
  "Open a new line below the current line, put the point there."
  (interactive)
  (end-of-line)
  (newline-and-indent)
  (god/exit-god-local))

(defun god/pull-line ()
  "Pull a line up from below the currnet line and join them."
  (interactive)
  (next-line)
  (join-line))
#+end_src

**** Insert Ahead

I want some way to intuitively leave god mode one character over from where I scanned to with seeking or moving forward and backward.

This comes in handy because sometimes words separated by non-word characters can put you in a spot where if you could move just one character "over", you could be right where you want to land without having to move a whole word/thing over the mark and back again.

#+begin_src elisp
(defvar-local god/ahead-direction 1
  "A cached value of the presumed `god/insert-ahead' direction.")

(defun god/set-ahead-direction (&optional dir)
  "Set `god/ahead-direction'. If `DIR' is 1, it's forward.
A value of -1 is backward.'"
  (let ((direction (or dir 1)))
    (unless (= direction god/ahead-direction)
      (setq-local god/ahead-direction direction))))

(defun god/insert-ahead (&rest args)
  "Move the cursor in `god/ahead-direction' and exit `god-local-mode'."
  (interactive)
  (forward-char god/ahead-direction)
  (god-local-mode -1))

(add-hook 'god-local-mode-hook
          #'(lambda () (god/set-ahead-direction)))

(dolist (back-func '(backward-char
                     backward-word
                     god/backward-symbol
                     isearch-backward
                     isearch-backward-regexp
                     search-backward
                     search-backward-regexp))
  (advice-add back-func :after
              #'(lambda (&rest args) (god/set-ahead-direction -1))
              (function 'god/set-ahead-backward)))

(dolist (for-func '(forward-char
                    forward-word
                    forward-symbol
                    isearch-forward
                    isearch-forward-regexp
                    search-backward
                    search-forward-regexp))
  (advice-add for-func :after
              #'(lambda (&rest args) (god/set-ahead-direction))
              (function 'god/set-ahead-forward)))
#+end_src

**** Org Mode Newline Advice

I would like to be able to perform special org-mode functions such as ~org-meta-return~ and ~org-insert-todo-heading~ and have ~god-local-mode~ turn off automatically.

#+begin_src elisp
(advice-add 'org-meta-return :after
            #'god/exit-god-local
            (function 'god/insert-after-org-meta-return))

(advice-add 'org-insert-todo-heading :after
            #'god/exit-god-local
            (function 'god/insert-after-org-new-heading))

(advice-add 'org-insert-heading-respect-content :after
            #'god/exit-god-local
            (function 'god/insert-after-org-heading-respect-content))
#+end_src

**** Seeking Characters

I envied Vim's ability to use =f= or =t= to quickly jump to, or just past a char target. I wrote my own solution. You can even repeat the last seek, or throw it into reverse with a negative argument.

#+begin_src elisp
(defvar god/previous-seek-motion nil
  "The previous until/find motion performed by god-mode.")

(defun god/seek (n &optional until-p repeat-ch)
  "Move the cursor forward, or backword to the nearest char in `N' direction.
Can be called with a `REPEAT-CH' to automatically seek for or `UNTIL-P' a char."
  (interactive "p")
  (let* ((case-fold-search nil)
         (ch (or repeat-ch
                 (read-char
                  (message "Seek%s(%d):" (if until-p "-Until" "") n))))
         (ch-str (if (eq ch 13) "\n" (char-to-string ch)))
         (fix-pos (if until-p (if (< n 0) 1 -1) 0))
         end)
    (save-excursion
      (if (< n 0) (forward-char -1) (forward-char 1))
      (setq end (search-forward ch-str nil t n)))
    (if (not end)
        (message "char %s not found" ch-str)
      (setq god/previous-seek-motion `(god/seek ,n ,until-p ,ch))
      (god/set-ahead-direction n)
      (goto-char (+ end (if until-p fix-pos 0))))))

(defun god/seek-until (neg-arg &optional repeat-ch)
  "Seek up to but not including a char.
Direction can be modified with a `NEG-ARG'. Can be repeated with a `REPEAT-CH'."
  (interactive "p")
  (god/seek neg-arg t repeat-ch))

(defun god/repeat-seek (reverse)
  "Repeat the `god/previous-seek-motion'.
Apply a neg-arg to go in `REVERSE'"
  (interactive "p")
  (when god/previous-seek-motion
    (let ((func (car god/previous-seek-motion))
          (num (cadr god/previous-seek-motion))
          (until (caddr god/previous-seek-motion))
          (ch (cadddr god/previous-seek-motion)))
      (funcall func (if (< reverse 0) (* num -1) num) until ch))))
#+end_src

**** Cursor Indicator

I like having a thick bar for "emacs mode" and a box for god-mode.

#+begin_src elisp
(setq cursor-type '(bar . 4))

(defun god/cursor-toggle ()
  "Toggle the cursor between a box and bar while in or out of `god-mode'."
  (setq cursor-type (if (bound-and-true-p god-local-mode)
                        'box
                      '(bar . 4))))
#+end_src

**** Keybindings

Declare key-bindings to be applied in the next section.

#+begin_src elisp
(defvar god/keybinds '((";" . god/repeat-seek)
                       ("A" . god/boi-insert)
                       ("B" . god/backward-symbol)
                       ("C" . god/change)
                       ("D" . delete-backward-char)
                       ("E" . god/eol-insert)
                       ("F" . forward-symbol)
                       ("g" . avy-goto-char-timer)
                       ("I" . god/insert-ahead)
                       ("i" . god-local-mode)
                       ("J" . god/pull-line)
                       ("O" . god/open-above)
                       ("o" . god/open-below)
                       ("W" . td/windmove-map)
                       ("T" . god/seek)
                       ("t" . god/seek-until)
                       ("P" . td/backward-chunk)
                       ("N" . td/forward-chunk)
                       ("(" . kmacro-start-macro)
                       (")" . kmacro-end-or-call-macro)
                       ("{" . backward-paragraph)
                       ("}" . forward-paragraph)
                       ("u" . undo)
                       ("U" . undo-redo)
                       ("q" . quit-window)
                       ("z" . repeat)
                       ("," . er/keymap)))
#+end_src

**** Apply & Finish Setup

I want god mode to be available to me everywhere. To do this, ~god-exempt-major-modes~ needs to be unset before loading =god-mode=.

I would prefer to keep god mode on, or off, on a buffer-to-buffer basis. I use ~god-local-mode~ for this.

God has no intermediary mode for non-editing buffers. I feel like it's better to have to turn it on explicitly for quicker navigation or firing off commands.

#+begin_src elisp
(setq god-mode-alist '((nil . "C-")
                       ("m" . "M-")
                       ("M" . "C-M-")))
(setq god-mode-enable-function-key-translation nil)

(with-eval-after-load 'god-mode
  (add-hook 'after-init-hook #'god-mode)
  (require 'god-mode-isearch)
  (dolist (mode '(notmuch-hello-mode
                  notmuch-search-mode
                  notmuch-show-mode
                  vterm-mode))
    (add-to-list 'god-exempt-major-modes mode))

  (add-to-list 'emulation-mode-map-alists
               `((god-local-mode . ,god-local-mode-map)))

  (td/bind-keys god/keybinds god-local-mode-map)

  (define-key isearch-mode-map (kbd "<escape>") #'god-mode-isearch-activate)
  (define-key god-mode-isearch-map (kbd "<escape>") #'god-mode-isearch-disable)

  (god/cursor-toggle)
  (add-hook 'post-command-hook #'god/cursor-toggle)

  (with-eval-after-load 'which-key
    (which-key-enable-god-mode-support)))

(td/bind-keys '(("C-c G"    . god-mode-all)
                ("C-c g"    . god-local-mode) ; Non-graphical fallback.
                ("<escape>" . god-local-mode)))
#+end_src

*** Goggles

Extra feedback for text changes.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-goggles"
#+end_src

#+begin_src elisp
(td/add-hooks '(text-mode prog-mode) #'goggles-mode)
(setq-default goggles-pulse t)
#+end_src

*** Imenu

#+begin_src elisp
(global-set-key (kbd "C-c i") #'imenu)
#+end_src

*** COMMENT Meow
Meow is a pretty special and ambitious modal editing project. It takes inspiration from Vim, Kakuone and god-mode to create a selection first, complete modal experience.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-meow"
#+end_src

#+begin_src elisp
(defun meow-setup ()
  (setq meow-cheatsheet-layout meow-cheatsheet-layout-qwerty
        meow-expand-hint-remove-delay 2.0
        meow-expand-exclude-mode-list '())
  (dolist (state '((notmuch-hello-mode  . motion)
                   (notmuch-search-mode . motion)
                   (notmuch-tree-mode   . motion)
                   (notmuch-show-mode   . motion)))
    (add-to-list 'meow-mode-state-list state))
  (meow-motion-overwrite-define-key
   '("h" . meow-left)
   '("j" . meow-next)
   '("k" . meow-prev)
   '("l" . meow-right)
   '("e" . forward-word)
   '("b" . backward-word)
   '("<escape>" . ignore))
  (meow-leader-define-key
   ;; Set up fallbacks for motion state.
   '("h" . "H-h")
   '("j" . "H-j")
   '("k" . "H-k")
   '("l" . "H-l")
   '("e" . "H-e")
   '("b" . "H-b")
   ;; Use SPC (0-9) for digit arguments.
   '("1" . meow-digit-argument)
   '("2" . meow-digit-argument)
   '("3" . meow-digit-argument)
   '("4" . meow-digit-argument)
   '("5" . meow-digit-argument)
   '("6" . meow-digit-argument)
   '("7" . meow-digit-argument)
   '("8" . meow-digit-argument)
   '("9" . meow-digit-argument)
   '("0" . meow-digit-argument)
   '("/" . meow-keypad-describe-key)
   '("?" . meow-cheatsheet)
   '("w" . td/windmove-map)
   '("H" . display-local-help)
   ;; Custom keybinds
   (cons "P" project-prefix-map))
  (meow-normal-define-key
   '("0" . meow-expand-0)
   '("9" . meow-expand-9)
   '("8" . meow-expand-8)
   '("7" . meow-expand-7)
   '("6" . meow-expand-6)
   '("5" . meow-expand-5)
   '("4" . meow-expand-4)
   '("3" . meow-expand-3)
   '("2" . meow-expand-2)
   '("1" . meow-expand-1)
   '("-" . negative-argument)
   '(";" . meow-reverse)
   '("," . meow-inner-of-thing)
   '("." . meow-bounds-of-thing)
   '("[" . meow-beginning-of-thing)
   '("]" . meow-end-of-thing)
   '("{" . meow-page-up)
   '("}" . meow-page-down)
   '("a" . meow-append)
   '("A" . meow-open-below)
   '("b" . meow-back-word)
   '("B" . meow-back-symbol)
   '("c" . meow-change)
   '("d" . meow-delete)
   '("D" . meow-backward-delete)
   '("e" . meow-next-word)
   '("E" . meow-next-symbol)
   '("f" . meow-find)
   '("g" . meow-cancel-selection)
   '("G" . meow-grab)
   '("h" . meow-left)
   '("H" . meow-left-expand)
   '("i" . meow-insert)
   '("I" . meow-open-above)
   '("j" . meow-next)
   '("J" . meow-next-expand)
   '("k" . meow-prev)
   '("K" . meow-prev-expand)
   '("l" . meow-right)
   '("L" . meow-right-expand)
   '("m" . meow-join)
   '("n" . meow-search)
   '("o" . meow-block)
   '("O" . meow-to-block)
   '("p" . meow-yank)
   '("q" . meow-quit)
   '("Q" . meow-goto-line)
   '("r" . meow-replace)
   '("R" . meow-swap-grab)
   '("s" . meow-kill)
   '("t" . meow-till)
   '("u" . meow-undo)
   '("U" . undo-redo)
   '("v" . meow-visit)
   '("w" . meow-mark-word)
   '("W" . meow-mark-symbol)
   '("x" . meow-line)
   '("X" . meow-goto-line)
   '("y" . meow-save)
   '("Y" . meow-sync-grab)
   '("z" . meow-pop-selection)
   '("'" . repeat)
   '("<escape>" . ignore)
   '("S" . surround)
   '("P" . td/backward-chunk)
   '("N" . td/forward-chunk)
   '("=" . er/expand-region)
   '(":" . avy-goto-char-timer)))

(require 'meow)
(setq meow-use-cursor-position-hack t
      meow-cursor-type-region-cursor '(bar . 4)
      meow-cursor-type-insert '(bar . 4))

(defun meow/auto-insert-mode (&rest args)
  "An advice function for entering insert mode."
  (meow-insert))

(advice-add 'org-meta-return :after #'meow/auto-insert-mode)
(advice-add 'org-insert-todo-heading :after #'meow/auto-insert-mode)
(advice-add 'org-insert-heading-respect-content :after #'meow/auto-insert-mode)

(meow-setup)
(meow-global-mode 1)
#+end_src

*** Magit

Magit is one of the biggest reasons why I fell in love with emacs. It's the best keyboard driven "TUI" abstraction of the git command line anywere, period. Better than Fugitive by far. Sorry, Tim Pope.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-magit"
#+end_src

#+begin_src elisp
(global-set-key (kbd "C-c m") #'magit-status)
#+end_src

*** Mastodon

Toot.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-mastodon"
#+end_src

#+begin_src elisp
(setq mastodon-instance-url "https://mastodon.technology"
      mastodon-active-user "trevdev"
      mastodon-tl--show-avatars t
      mastodon-media--avatar-height 30)
#+end_src

*** Multiple Cursors

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-multiple-cursors"
#+end_src

#+begin_src elisp
(td/bind-keys '(("C-S-l"   . mc/edit-lines)
                ("C->"     . mc/mark-next-like-this)
                ("C-<"     . mc/mark-previous-like-this)
                ("C-M->"   . mc/skip-to-next-like-this)
                ("C-M-<"   . mc/skip-to-previous-like-this)
                ("C-c C-?" . mc/mark-all-like-this-dwim)
                ("C-c C-/" . mc/mark-all-in-region)
                ("C-M-n"   . mc/insert-numbers)
                ("C-M-a"   . mc/insert-letters))
              priority-mode-map)
#+end_src

*** Org

The greatest part of using Emacs is org-mode. It handles my agenda, my todo list, helps me prioritize tasks, track time and invoice clients.

**** Key Variables

I am using tags to help sort contexts within my agenda. Some people use categories for that. I technically do that, too, but I also use separate files. Filenames are categories by default, so there is less to configure when you use separate files.

#+begin_src elisp
(defvar td/tag-list
  '((:startgroup)
    ("@home" . ?H)
    ("@work" . ?W)
    (:endgroup)
    ("foss"  . ?f)
    ("gurps" . ?g)
    ("idea"  . ?i))
  "The tags for org headlines.")
#+end_src

Next are my TODO key words. They are meant to be used as such:

- =TODO= A generic task or actionable thing.
- =NEXT= A planned task, something I am setting my mind to until it is done. There should be very few of these types of tasks so that I am setting achievable goals
- =WAIT= The task that is held up by some pre-requesite or external factor
- =LOW= The task is a "maybe/someday" task. I'd like to see it done, but it's not a priority right now.
- =DONE= The task is completed
- =PASS= The task has been "passed along" or "delegated" to someone else. Considered 'done', just not by myself
- =CANC= The task has been cancelled or ended before completion

#+begin_src elisp
(defvar td/todo-keywords
  '((sequence "TODO(t)" "NEXT(n)" "WAIT(w@/!)" "LOW(l)"
              "|" "DONE(d!)" "PASS(p@)" "CANC(k@)"))
  "A sequence of keywords for Org headlines.")
#+end_src

My org agenda commands & stuck projects. Currently a work in progress! I am reading David Allen's "[[https://gettingthingsdone.com/][Getting Things Done]]." I am attempting to shape my agenda to suit that system.

#+begin_src elisp
(defvar td/org-agenda-commands
  '(("d" "Dashboard: Get things done!"
     ((agenda "" ((org-agenda-span 7)))
      (tags-todo "+refile"
                 ((org-agenda-overriding-header "Unfiled")))
      (tags-todo "+PRIORITY=\"A\""
                 ((org-agenda-overriding-header "High Priority")
                  (org-agenda-skip-function
                   '(org-agenda-skip-entry-if 'todo '("WAIT")))))
      (todo "NEXT"
            ((org-agenda-overriding-header "Do Next")
             (org-agenda-max-todos nil)))
      (todo "WAIT"
            ((org-agenda-overriding-header "Follow Up")))
      (todo "TODO"
            ((org-agenda-overriding-header "Other Actionables")
             (org-agenda-skip-function
              '(org-agenda-skip-entry-if 'scheduled 'deadline))))
      )
     )
    ("l" "Backburner of low priority tasks"
     ((todo "LOW"
           ((org-agenda-overriding-header "Someday/Maybe"))))
     )
    )
  "Custom commands for Org Agenda.")
#+end_src

Capture templates! These help me collect information into Org files. Currently I only have 2 cookbook capture methods that are meant to be used with org-chef. See [[*Extending Org Mode][extensions]] for how I extend org-mode.

#+begin_src elisp
(defvar td/capture-templates
  '(("t" "Todo" entry (file "~/Org/agenda/inbox.org")
     "* TODO %^{Title: }\n:PROPERTIES:\n:date: %U\n:END:\n%?"
     :empty-lines 1)
    ("c" "Contact" entry (file+headline "~/Org/contacts.org" "Other")
     "* %^{Name: }\n:PROPERTIES:\n:email: %?\n:END:"
     :empty-lines 1))
  "Base org-capture-templates.")

(global-set-key (kbd "C-c M-a") #'org-capture)
#+end_src

I usually stick to monospace sized fonts with the exception of Org files. I like the first 3 levels to be slightly larger than the rest, and progressively smaller. This helps me create a sense of urgency at the lower-level headers and it also improves readability.

**** Functions
Some fairly self-explanatory utility functions.

#+begin_src elisp
(defvar td/org-scale-levels-enable nil
  "Whether or levels are scaled.")

(defun td/org-scale-levels-toggle (&optional enable)
  "Enlarge org levels for more readability."
  (interactive)
  (let ((scaled (or enable (not td/org-scale-levels-enable))))
    (dolist (face '((org-level-1 . (if scaled 1.2 1.0))
                    (org-level-2 . (if scaled 1.1 1.0))
                    (org-level-3 . (if scaled 1.05 1.0))))
      (set-face-attribute (car face) nil :weight 'semi-bold :height (eval (cdr face))))
    (setq td/org-scale-levels-enable scaled)))

(defun td/org-hook ()
  "Do some stuff on org mode startup."
  (org-clock-persistence-insinuate)
  (org-indent-mode)
  (setq-local line-spacing 0.1))

(defun td/org-append-templates (templates)
  (setq org-capture-templates (append org-capture-templates templates)))

;; Fix completion in steps for org-refile
(advice-add #'org-olpath-completing-read :around
            (lambda (&rest args)
              (minibuffer-with-setup-hook
                  (lambda () (setq-local completion-styles '(basic)))
                (apply args))))
#+end_src

**** Apply Configuration

#+begin_src elisp
(add-hook 'org-mode-hook #'td/org-hook)
(global-set-key (kbd "C-c a") #'org-agenda)

(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c e t") #'org-table-export))

(with-eval-after-load 'ox
  (require 'ox-md nil t))

(setq org-fontify-quote-and-verse-blocks t
      org-attach-auto-tag "attach"
      org-directory "~/Org"
      org-archive-location "archives/%s_archive::"
      org-log-done 'time
      org-log-into-drawer t
      org-enforce-todo-dependencies t
      org-src-preserve-indentation t
      org-clock-persist 'history
      org-agenda-block-separator "──────────"
      org-agenda-tags-column -80
      org-duration-format '(("h" . nil) (special . 2))
      org-clock-total-time-cell-format "%s"
      org-agenda-files '("~/Org/agenda")
      org-tag-alist td/tag-list
      org-todo-keywords td/todo-keywords
      org-refile-use-outline-path 'file
      org-refile-allow-creating-parent-nodes t
      org-refile-targets '((org-agenda-files :maxlevel . 4)
                           ("contacts.org" :maxlevel . 1))
      org-clock-sound "~/.config/emacs/inspectorj_bell.wav"
      org-timer-default-timer "25"
      org-agenda-custom-commands td/org-agenda-commands
      org-stuck-projects '("/PROJ-DONE" ("TODO" "NEXT") nil "- \\[ \\]")
      org-capture-templates td/capture-templates
      org-catch-invisible-edits 'show-and-error
      org-special-ctrl-a/e t
      org-insert-heading-respect-content t)

(add-to-list 'display-buffer-alist '("\\*Org Agenda*\\*"
                                     (display-buffer-in-direction)
                                     (direction . right)
                                     (window-width . 0.50)
                                     (window-height . fit-window-to-buffer)))
#+end_src

**** Extending Org Mode
Extending org-mode with some interesting packages.

***** COMMENT org-alert

Libnotify alerts for Agenda alerts.

#+begin_src elisp
(straight-use-package 'org-alert)

(with-eval-after-load 'org
  (require 'org-alert)
  (setq alert-default-style 'libnotify
        org-alert-interval 7200
        org-alert-notify-cutoff 60
        org-alert-notification-title "Org Agenda")
  (org-alert-enable))
#+end_src

***** org-chef

[[https://github.com/Chobbes/org-chef][Org-chef]] is a must have if you enjoy cooking. You can just use =M-x org-chef-insert-recipe= in whatever cookbook file, or the capture templates.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-org-chef"
#+end_src

#+begin_src elisp
(td/org-append-templates
 '(("r" "Recipe" entry (file "~/Projects/cookbook/src/cookbook.org")
    "%(org-chef-get-recipe-from-url)"
    :empty-lines 1)
   ("m" "Manual Cookbook" entry
    (file "~/Projects/cookbook/src/cookbook.org")
    (eval (concat "* %^{Recipe title: }\n  :PROPERTIES:\n  :source-url:\n"
            "  :servings:\n  :prep-time:\n  :cook-time:\n  :ready-in:\n"
            "  :END:\n** Ingredients\n   %?\n** Directions\n\n")))))
#+end_src

***** ox-gfm

Get access to Github Flavored Markdown

#+begin_src scheme packages :noweb-ref packages :tangle no :exports none
"emacs-ox-gfm"
#+end_src

#+begin_src elisp
(with-eval-after-load 'ox
  (require 'ox-gfm))
#+end_src

***** ox-hugo

I like org-publish, but there are some files (like my cookbook) that I would like to keep in one document, as it is a capture file, and be able to easily publish it into a list of "posts".

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-ox-hugo"
#+end_src

#+begin_src elisp
(with-eval-after-load 'ox
  (require 'ox-hugo))
#+end_src

***** org-present

A tiny package for presenting with org-mode.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-org-present"
#+end_src

#+begin_src elisp
(setq org-present-text-scale 5)
(with-eval-after-load 'org-present
  (add-hook 'org-present-mode-hook
            #'(lambda ()
                (org-present-big)
                (td/org-scale-levels-toggle t)
                (org-display-inline-images)
                (blink-cursor-mode -1)
                (org-present-hide-cursor)
                (org-present-read-only)))
  (add-hook 'org-present-mode-quit-hook
            #'(lambda()
                (org-present-small)
                (org-remove-inline-images)
                (org-present-show-cursor)
                (blink-cursor-mode 1)
                (td/org-scale-levels-toggle)
                (org-present-read-write)))
  (td/bind-keys '(("C-c C-p C-c" . org-present-show-cursor)
                  ("C-c C-p C-h" . org-present-hide-cursor))
                org-present-mode-keymap))
#+end_src

***** COMMENT org-roam

Org roam is an incredible thought capture system, inspired by roam research. I'm not sure this one's for me, but I am giving it a try.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-org-roam"
#+end_src

#+begin_src elisp
(defvar td/roam-capture-templates
  '(("d" "default" plain "%?"
     :target (file+head "%<%Y%m%d%H%M%S>-${slug}.org"
                        "#+TITLE: ${title}\n#+DATE: %U\n")
     :unnarrowed t)))

(defvar td/roam-capture-daily
  '(("d" "default" entry "* %<%I:%M %p>: %?"
     :target (file+head "%<%Y-%m-%d>.org"
                        "#+TITLE: %<%a, %b %d %Y>\n"))
    ("p" "Private" entry "* %<%I:%M %p>: %?"
     :target (file+head "%<%Y-%m-%d>.org.gpg"
                        "#+TITLE: %<%a, %b %d %Y>\n"))))

(defvar td/roam-display-template
  (concat "${title} "
          (propertize "${tags}" 'face 'org-tag)))

(td/bind-keys '(("C-c r t" . org-roam-buffer-toggle)
                ("C-c r f" . org-roam-node-find)
                ("C-c r i" . org-roam-node-insert)
                ("C-c r c" . org-roam-capture)
                ("C-c r d i" . org-roam-dailies-capture-today)
                ("C-c r d t" . org-roam-dailies-goto-today)
                ("C-c r d y" . org-roam-dailies-goto-yesterday)
                ("C-c r d d" . org-roam-dailies-goto-date)))

(setq org-roam-capture-templates td/roam-capture-templates
      org-roam-dailies-capture-templates td/roam-capture-daily
      org-roam-node-display-template td/roam-display-template
      org-roam-db-node-include-function
      (lambda ()
        (not (member "attach" (org-get-tags))))
      org-roam-directory (file-truename "~/Org/roam"))

(add-to-list 'display-buffer-alist '("\\*org-roam\\*"
                                     (display-buffer-in-direction)
                                     (direction . right)
                                     (window-width . 0.33)
                                     (window-height . fit-window-to-buffer)))



(with-eval-after-load 'org-roam
  (org-roam-db-autosync-mode))
#+end_src

***** COMMENT org-roam-ui

A fancy, web-based user interface for reviewing your org-roam notes and how they connect to one-another.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-org-roam-ui"
#+end_src

#+begin_src elisp
(setq org-roam-ui-sync-theme t
      org-roam-ui-follow t
      org-roam-ui-update-on-save t
      org-roam-ui-open-on-start t)
#+end_src

***** COMMENT org-invoice-table

A custom table formatter for invoicing.

#+begin_src elisp
(load-file "~/Projects/org-invoice-table/org-invoice-table.el")
#+end_src

*** Ledger
Knowing what resources you have at your disposal and learning how to budget are powerful things.

Note: this is probably built into the Guix ledger package. If something breaks, check into that.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-ledger-mode"
#+end_src

#+begin_src elisp
(setq ledger-use-native-highlighting t)
#+end_src

*** Vterm

A "normal" terminal for Emacs. This package is currently installed by the guix system.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-vterm"
"emacs-vterm-toggle"
"emacs-multi-vterm"
#+end_src

#+begin_src elisp
(td/bind-keys '(("C-c v t" . multi-vterm)
                ("C-c v n" . multi-vterm-next)
                ("C-c v p" . multi-vterm-prev)
                ("C-c v d" . multi-vterm-dedicated-toggle)
                ("C-c v P" . multi-vterm-project)))
#+end_src

*** Notmuch

Notmuch is a really impressive way to read and organize mail via tagging files. It works really quickly and the configuration is really flexible.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"notmuch"
"emacs-notmuch"
#+end_src

**** Built In Mail Settings

#+begin_src elisp
(setq send-mail-function 'sendmail-send-it
      sendmail-program "~/.guix-home/profile/bin/msmtp"
      message-directory "~/.local/share/mail"
      mail-specify-envelope-from t
      mail-envelope-from 'header
      message-sendmail-envelope-from 'header
      message-signature-directory "~/.local/share/mail/signatures"
      message-signature-file "default")
#+end_src

**** Notmuch

#+begin_src elisp
(setq notmuch-fcc-dirs
      '(("trev@fastmail.com" . "fastmail/Sent")
        ("trev@trevdev.ca"   . "fastmail/Sent")
        ("tn@eml.cc"         . "fastmail/Sent")
        ("trevor@voltagenewmedia.com" . "voltage/Sent"))
      notmuch-saved-searches '(
                               (:name "todo"
                                      :query "tag:todo"
                                      :key "t"
                                      :sort-order newest-first)
                               (:name "flagged"
                                      :query "tag:flagged"
                                      :key "f"
                                      :sort-order newest-first)
                               (:name "personal"
                                      :query "not tag:work"
                                      :count-query "not tag:work and tag:unread"
                                      :key "p"
                                      :sort-order newest-first)
                               (:name "work"
                                      :query "tag:work"
                                      :count-query "tag:work and tag:unread"
                                      :key "w"
                                      :sort-order newest-first)
                               (:name "lists"
                                      :query "tag:list"
                                      :count-query "tag:list and tag:unread"
                                      :key "l"
                                      :sort-order newest-first)
                               (:name "drafts"
                                      :query "tag:draft"
                                      :key "d"
                                      :sort-order newest-first)
                               (:name "sent"
                                      :query "tag:sent"
                                      :count-query "tag:nil"
                                      :key "s"
                                      :sort-order newest-first)
                               (:name "archive"
                                      :count-query "tag:nil"
                                      :query "tag:archive"
                                      :key "a"
                                      :sort-order newest-first)
                               (:name "all mail"
                                      :query "*"
                                      :count-query "tag:nil"
                                      :key "A"
                                      :sort-order newest-first))
      notmuch-archive-tags '("+archive" "-inbox")
      notmuch-tagging-keys '(("a" notmuch-archive-tags "Archive")
                             ("u" notmuch-show-mark-read-tags "Mark read")
                             ("f" ("+flagged") "Flag")
                             ("s" ("+spam" "-inbox") "Mark as spam")
                             ("d" ("+deleted" "-inbox") "Delete"))
      notmuch-show-logo nil
      notmuch-mua-user-agent-function 'notmuch-mua-user-agent-full
      notmuch-hello-thousands-separator ","
      mml-secure-openpgp-encrypt-to-self t)

(global-set-key (kbd "<f5>") #'notmuch)

(defun td/specify-msmtp-account ()
  (save-excursion
    (beginning-of-buffer)
    (search-forward "From:")
    (setq message-sendmail-extra-arguments
          (if (string-match-p (regexp-quote "voltagenewmedia")
                              (thing-at-point 'line t))
              (list "-a" "voltage")
            (list "-a" "default")))))

(add-hook 'notmuch-mua-send-hook #'td/specify-msmtp-account)

(autoload 'notmuch-message-mode "notmuch-mua.el"
  "Activate the notmuch message mode and its corresponding keymap" t)
#+end_src

**** ol-notmuch

The *emacs-ol-notmuch* package gives me the ability to link notmuch message files in org-mode.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-ol-notmuch"
#+end_src

**** org-mime

Edit messages in Orgdown and transform them into multipart html messages with the *org-mime* package.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-org-mime"
#+end_src

#+begin_src elisp
(autoload 'org-mime-edit-mail-in-org-mode "org-mime"
  "Edit a message in org-mode"
  t)

(setq org-mime-export-options
      '(:with-latex dvipng :section-numbers nil :with-author nil :with-toc nil))

(with-eval-after-load 'notmuch
  (td/bind-keys '(("C-c C-o" . org-mime-edit-mail-in-org-mode)
                  ("C-c C-h" . org-mime-htmlize))
                message-mode-map))
#+end_src

**** org-contacts

Organize contacts with org-mode.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-org-contacts"
#+end_src

#+begin_src elisp
(with-eval-after-load 'org
  (require 'org-contacts)
  (setq org-contacts-files '("~/Org/contacts.org")))
#+end_src

*** Password Store

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-password-store"
#+end_src

#+begin_src elisp
(td/bind-keys '(("C-c p c" . password-store-copy)
                ("C-c p f" . password-store-copy-field)
                ("C-c p i" . password-store-insert)
                ("C-c p g" . password-store-generate)))
#+end_src

*** Sensitive Mode

Inspired from a script written by [[https://anirudhsasikumar.net/blog/2005.01.21.html][Anirudh Sasikumar]]. It has been adapted to accomodate undo-tree. This prevents emacs from generating unencrypted backups & autosave data from =.gpg= files.

#+begin_src elisp
(define-minor-mode sensitive-mode
  "A minor-mode for preventing auto-saves and back-ups for encrypted files."
  :global nil
  :lighter " Sensitive"
  :init-value nil
  (if (symbol-value sensitive-mode)
      (progn
        ;; disable backups
        (set (make-local-variable 'backup-inhibited) t)
        ;; disable auto-save
        (if auto-save-default
            (auto-save-mode -1))
        ;; disable undo-tree history(?)
        (when (bound-and-true-p undo-tree-mode)
          (undo-tree-mode -1)))
    (kill-local-variable 'backup-inhibited)
    (if auto-save-default
        (auto-save-mode 1))
    (when (bound-and-true-p global-undo-tree-mode)
      (undo-tree-mode 1))))
#+end_src

*** RG

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-rg"
#+end_src

#+begin_src elisp
(rg-enable-default-bindings)
#+end_src

*** Transpose Mark

A simple package for highlighting a marked area or region prior to transposing it with some other marked area or region. It makes the built-in =transpose-region= sane.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-transpose-mark"
#+end_src

#+begin_src elisp
(global-set-key (kbd "C-c t") #'transpose-mark)
#+end_src

*** Visual Fill Column

Creates a fake "fill column" to wrap text around. Makes reading documents more visually appealing without breaking text into newlines.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-visual-fill-column"
#+end_src

#+begin_src elisp
(defun td/visual-fill-setup ()
  "Center the column 100 characters wide."
  (setq-local visual-fill-column-width 100
              visual-fill-column-center-text nil)
  (visual-fill-column-mode 1))

(with-eval-after-load 'org
  (define-key org-mode-map (kbd "C-c v") #'visual-fill-column-mode))

(add-hook 'org-mode-hook #'td/visual-fill-setup)
#+end_src

*** Which-key
What the heck was that keybind again? If you can remember how it starts, which-key can help you find the rest.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-which-key"
#+end_src

#+begin_src elisp
(which-key-mode)
#+end_src

*** Windmove

Set up a keymap for wind-move and bind it to a prefix that's easy to hit.

#+begin_src elisp
(defvar td/windmove-map
  (let ((map (make-sparse-keymap)))
    (td/bind-keys '(("e"   . windmove-right)
                    ("a"   . windmove-left)
                    ("n"   . windmove-down)
                    ("p"   . windmove-up)
                    ("s e" . windmove-swap-states-right)
                    ("s a" . windmove-swap-states-left)
                    ("s n" . windmove-swap-states-down)
                    ("s p" . windmove-swap-states-up)
                    ("d e" . windmove-delete-right)
                    ("d a" . windmove-delete-left)
                    ("d n" . windmove-delete-down)
                    ("d p" . windmove-delete-up)
                    ("d d" . delete-window)
                    ("D" . delete-other-windows)
                    ("o"   . other-window)
                    ("v"   . split-window-right)
                    ("h"   . split-window-below)
                    ("="   . enlarge-window)
                    ("-"   . shrink-window)
                    ("b"   . balance-windows))
                  map)
    map)
  "A keymap for windmove functions.
\\{td/windmove-map}")

(fset 'td/windmove-map td/windmove-map)

(global-set-key (kbd "M-o") td/windmove-map)
#+end_src

** Syntax Support
:PROPERTIES:
:header-args: :tangle .emacs.d/init.el :comments link
:END:

This section is all about enhancing support for programming languages. Some of the headlines are package configurations. Others are a record of enhanced syntax support, most likely through some third party package that requires no further configuration.

*** Clojure

Clojure is supported by =clojure-mode= and =cider=.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-clojure-mode"
"emacs-cider"
#+end_src

#+begin_src elisp
(td/auto-mode '(("\\.clj\\'" . clojure-mode)))
#+end_src

*** Lisp

This configuration has enhanced support for the following dialects:

- Common Lisp with the =sly= REPL package
- Guile Scheme with the =geiser-guile= REPL package

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-sly"
"emacs-geiser-guile"
#+end_src

*** CSS/SCSS

#+begin_src elisp
(setq css-indent-offset 2
      tab-width 2)
#+end_src

*** Emmet

Emmet is its own snippet engine for expanding html tags and nesting and is made possible by =emmet-mode=.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-emmet-mode"
#+end_src

#+begin_src elisp
(setq emmet-expand-jsx-className t)
(td/add-hooks '(sgml-mode
                css-mode
                web-mode
                svelte-mode)
              #'emmet-mode)
#+end_src

*** Flycheck

The popular =flycheck= package helps me lint various files. I use this in conjunction with [[* LSP Mode][lsp-mode]] as the two are meant to work together.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-flycheck"
#+end_src

#+begin_src elisp
(td/add-hooks '(emacs-lisp-mode prog-mode ledger-mode) #'flycheck-mode)
(define-key prog-mode-map (kbd "C-c f") #'flycheck-mode)
(with-eval-after-load 'flycheck
  (setq flycheck-checker-error-threshold 1000))
#+end_src

*** LSP Mode

LSP support is delivered by =lsp-mode= and =lsp-ui=.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-lsp-mode-with-plists"
"emacs-lsp-ui"
#+end_src

#+begin_src elisp
(td/add-hooks '(css-mode
                scss-mode
                html-mode
                js-mode
                json-mode
                python-mode
                php-mode
                ruby-mode
                rust-mode
                scss-mode
                svelte-mode
                typescript-mode
                vue-mode
                yaml-mode)
              #'lsp)
(add-hook 'lsp-mode-hook #'lsp-enable-which-key-integration)

(setq lsp-keymap-prefix "C-c l")
(setq lsp-log-io nil
      lsp-modeline-code-actions-segments '(count)
      lsp-signature-doc-lines 1
      lsp-enable-folding nil
      lsp-completon-provider :none
      lsp-clients-typescript-server-args '("--stdio"
                                           "--tsserver-log-file"
                                           "/dev/stderr")
      lsp-keep-workspace-alive nil)

(with-eval-after-load 'lsp-mode
  (define-key lsp-mode-map (kbd "C-S-H") #'lsp-ui-doc-glance)
  (lsp-register-client
   (make-lsp-client :new-connection (lsp-stdio-connection
                                     "theme-check-language-server")
                    :activation-fn (lsp-activate-on "shopify")
                    :server-id 'theme-check))
  (add-to-list
   'lsp-file-watch-ignored-directories "[/\\]env' [/\\]__pycache__'")
  (add-to-list 'lsp-language-id-configuration
               '(shopify-mode . "shopify")))
#+end_src

*** Markdown

The free software documentation language of the Internet. Markdown support is made better with =markdown-mode=.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-markdown-mode"
#+end_src

#+begin_src elisp
(td/auto-mode '(("README\\.md\\'" . gfm-mode)
                ("\\.md\\'" . markdown-mode)
                ("\\.markdown\\'" . markdown-mode)))
#+end_src

*** COMMENT Nim

#+begin_src elisp
(straight-use-package 'nim-mode)
#+end_src

*** Paredit

The =paredit= package brings a sort of strictness to lisp/scheme editing while providing useful tools for manipulating lists as trees.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-paredit"
#+end_src

#+begin_src elisp
(td/add-hooks '(lisp-mode
                scheme-mode
                clojure-mode
                emacs-lisp-mode)
              #'enable-paredit-mode)
#+end_src

*** PHP

PHP support is made better with the =php-mode= package.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-php-mode"
#+end_src

#+begin_src elisp
(defun td/get-intelephense-key ()
  "Get my intelephense license key."
  (with-temp-buffer
    (insert-file-contents "~/Documents/intelephense.txt")
    (buffer-string)))

(defun td/get-wordpress-stubs ()
  "The stubs required for a WordPress Project"
  (json-insert ["apache" "bcmath" "bz2" "calendar" "com_dotnet" "Core"
                "ctype" "curl" "date" "dba" "dom" "enchant" "exif"
                "fileinfo" "filter" "fpm" "ftp" "gd" "hash" "iconv" "imap"
                "interbase" "intl" "json" "ldap" "libxml" "mbstring"
                "mcrypt" "meta" "mssql" "mysqli" "oci8" "odbc" "openssl"
                "pcntl" "pcre" "PDO" "pdo_ibm" "pdo_mysql" "pdo_pgsql"
                "pdo_sqlite" "pgsql" "Phar" "posix" "pspell" "readline"
                "recode" "Reflection" "regex" "session" "shmop" "SimpleXML"
                "snmp" "soap" "sockets" "sodium" "SPL" "sqlite3" "standard"
                "superglobals" "sybase" "sysvmsg" "sysvsem" "sysvshm" "tidy"
                "tokenizer" "wddx" "xml" "xmlreader" "xmlrpc" "xmlwriter"
                "Zend OPcache" "zip" "zlib" "wordpress"]))
#+end_src

*** Prettier

An opinionated way to clean up my web-dev code quickly. Prettier is made possible with the =prettier= package.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-prettier"
#+end_src

*** Python

Python support is enhanced with the =pyvenv= package. It helps manage virtualenvs.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-pyvenv"
#+end_src

*** Rainbow Delimiters

The =rainbow-delimeters= package makes nested scopes much easier to follow.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-rainbow-delimiters"
#+end_src

#+begin_src elisp
(add-hook 'prog-mode-hook #'rainbow-delimiters-mode)
#+end_src

*** Rainbow Mode

The =rainbow-mode= package makes color names and hex codes pop with their actual colors.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-rainbow-mode"
#+end_src

*** Ruby

Ruby support is made better with Solargraph (installed separately with Guix) and the =inf-ruby= package as a built-n REPL.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"ruby-solargraph"
"emacs-inf-ruby"
#+end_src

*** Rust

Enhanced Rust support comes from the =rust-mode= package.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-rust-mode"
#+end_src

#+begin_src elisp
(defun td/rust-run-args (s)
  (interactive "sOptional Args:")
  (rust--compile (concat "%s run " s) rust-cargo-bin))

(with-eval-after-load 'rust-mode
  (td/bind-keys '(("C-c c r" . rust-run)
                  ("C-c c a r" . td/rust-run-args))
                rust-mode-map))
#+end_src

*** Shopify Liquid

Enhance support for Shopify's own templating language. LSP support requires the use of Shopify's theme-check language server. I install this using Guix and my own personal channel for the gems required to build [[https://git.sr.ht/~trevdev/guix-channel/tree/main/item/trevdev/packages/ruby.scm#L100][shopify-cli]].

All of this brings me full Shopify developer support in Emacs.

#+begin_src elisp
(define-derived-mode shopify-mode web-mode "Shopify"
  "Use web mode to highlight shopify liquid files")
(provide 'shopify-mode)
(add-to-list 'auto-mode-alist '("\\.liquid\\'" . shopify-mode))
(defvar liquid-electric-pairs '((?% . ?%))
  "Electric pairs for liquid syntax.")
(defun liquid-add-electric-pairs ()
  (setq-local electric-pair-pairs (append electric-pair-pairs
                                          liquid-electric-pairs)
              electric-pair-text-pairs electric-pair-pairs))
(add-hook 'shopify-mode-hook #'liquid-add-electric-pairs)
#+end_src

*** Svelte

I extend [[* Web Mode][web-mode]] to enhance the syntax highlighting for =.svelte= files.

#+begin_src elisp
(define-derived-mode svelte-mode web-mode "Svelte"
  "I just want web-mode highlighting with .svelte files")
(provide 'svelte-mode)
(add-to-list 'auto-mode-alist '("\\.svelte\\'" . svelte-mode))
#+end_src

*** COMMENT Treesitter

Tree-sitter is an impressive project. It delivers exceptionally rich syntax highlighting for things like emacs/vim. A little tricky to theme, though, as it has a billion font lock faces and every tree-sitter syntax config may or may not use them the same way. I try to avoid looking a gift horse in the mouth.

#+begin_src elisp
(straight-use-package 'tree-sitter)
(straight-use-package 'tree-sitter-langs)

(defun td/start-tree-sitter ()
  "Fires up tree-sitter for select modes"
  (tree-sitter-mode)
  (tree-sitter-hl-mode))

(td/add-hooks '(js-mode
                typescript-mode
                css-mode
                rust-mode)
              #'td/start-tree-sitter)
#+end_src

*** TypeScript & JavaScript

I prefer the more minimal =typescript-mode= package for enhanced typescript syntax. The of my JS is handled by the built in =js-mode= and the typescript-language-server.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-typescript-mode"
#+end_src

#+begin_src elisp
(setq js-indent-level 2)
(setq typescript-indent-level 2)
#+end_src

*** VueJS

I extend [[* Web Mode][web-mode]] to enhance highlighting in =.vue= files.

#+begin_src elisp
(define-derived-mode vue-mode web-mode "VueJS"
  "I just want web-mode highlighting with .svelte files")
(provide 'vue-mode)
(add-to-list 'auto-mode-alist '("\\.vue\\'" . vue-mode))
#+end_src

*** Web Mode

There isn't a much better catch-all for web template syntax support than web-mode.

I don't like all of it's default tab-width settings so I override those.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-web-mode"
#+end_src

#+begin_src elisp
(td/auto-mode '(("\\.html\\'" . web-mode)))
(setq web-mode-markup-indent-offset tab-width
      web-mode-code-markup-indent-offset tab-width
      web-mode-style-padding tab-width
      web-mode-script-padding tab-width
      web-mode-block-padding tab-width
      web-mode-enable-auto-indentation nil
      web-mode-enable-auto-pairing nil)
#+end_src

*** YAML

YAML configurationf files are highlighted by =yaml-mode=.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-yaml-mode"
#+end_src

#+begin_src elisp
(td/auto-mode '(("\\.yml\\'" . yaml-mode)))
#+end_src

*** Yasnippet

Snippets are provided by the =yasnippet= and =yasnippet-snippets= packages.

#+begin_src scheme :noweb-ref packages :tangle no :exports none
"emacs-yasnippet"
"emacs-yasnippet-snippets"
#+end_src

#+begin_src elisp
(with-eval-after-load 'yasnippet
  (global-set-key (kbd "C-c ,") #'yas-expand)
  (setq yas-snippet-dirs '("~/.config/emacs/yasnippets"))
  (yas-reload-all))

(add-hook 'prog-mode-hook #'yas-minor-mode)
(add-hook 'text-mode-hook #'yas-minor-mode)
#+end_src

*** Load Customizer Settings

Load the file we created for custom vars in the [[* General Settings][general settings]].

#+begin_src elisp
(load custom-file 'noerror 'nomessage)
#+end_src

** Guix Package Module
:PROPERTIES:
:header-args: :tangle ~/.config/guix/home/tdev/emacs.scm
:END:

This section generates the Guile Scheme module that creates a Guix
package for this emacs init. It uses the =noweb= feature to tangle up
the relevant package dependencies.

#+begin_src scheme :noweb yes
;;; Guix Package Module
;;
;; This module was generated by tangling my literate emacs config
;; with org-mode.
;;
;; See: https://sr.ht/~trevdev/emacs.d/

(define-module (tdev emacs)
  #:use-module (gnu packages)
  #:use-module (guix packages)
  #:use-module (guix gexp)
  #:use-module (guix utils)
  #:use-module (guix build-system trivial)
  #:use-module (guix licenses)
  #:use-module (guix git-download)
  #:use-module (gnu packages emacs)
  #:use-module (gnu packages emacs-xyz)
  #:use-module (gnu packages matrix)
  #:use-module (gnu packages fonts)
  #:use-module (gnu packages mail)
  #:use-module (gnu packages ruby)
  #:export (emacs-init
            emacs-package-list))

(define emacs-package-list
  (list
   "emacs"
   <<packages>>))

(define emacs-init
  (package
   (name "emacs-init")
   (version "0.0.1")
   (source
    (origin
     (method git-fetch)
     (uri (git-reference
           (url "https://github.com/trev-dev/emacs")
           (commit "24889c5b6b6ed363a18796065639171537cfabd8")))
     (file-name (git-file-name name version))
     (sha256
      (base32 "1bjzadgliy52kmc47kgxw3bpc451ky8989v1lp5r1pw9zfa5xqzk"))))
   (inputs emacs-packages)
   (build-system trivial-build-system)
   (arguments
    (list
     #:modules '((guix build utils))
     #:builder
     #~(begin
         (use-modules (guix build utils))
         (copy-recursively #$source ".")
         (setenv "PATH" (string-append #$emacs "/bin"))
         (invoke "emacs" "--batch"
                 "--eval" "(require 'org)"
                 "--eval" "(org-babel-tangle-file \"config.org\")")
         (let ((dest (string-append #$output "/emacs.d")))
           (install-file ".emacs.d/init.el" dest)
           (install-file ".emacs.d/early-init.el" dest)))))
   (home-page "https://github.com/trev-dev/emacs")
   (synopsis "Trev's Emacs init files")
   (description "My init files as a package for the purposes of installing
on The GNU Guix System.")
   (license gpl3)))
#+end_src

** Installation

If you've decided to fork this repository and wish to use it as-is, here are the steps you'll need to take.

1. Clone this repository somewhere.
2. Tangle =config.org=. The resulting configuration files should be output to =.emacs.d/*.el=
3. Symlink, copy or move the config files to wherever you want to start your init.
4. Install the dependencies for this configuration somehow. It's designed to be used with GNU Guix, but so long as the dependencies are installed via package.el or straight.el, it should still work.

** Licenses

- For the [[file:inspectorj_bell.wav][bell sound]]: "Bell, Candle Damper, A (H4n).wav" by InspectorJ (www.jshaw.co.uk) of Freesound.org (Creative Commons - CC BY 3.0)

** Closing Thoughts

This literate configuration is a labour of love from a man who changes his mind and mixes things up /often/.

I'm not sure it will ever be finished or perfect. At times, things may clunk. I will do my best to clunk them in another branch.

If you like this config the way you found it, make sure that you fork it or make note of which commit you preferred.

If you like it enough to drop me a tip, feel free to do so:

[[https://ko-fi.com/Y8Y34UWHH][https://ko-fi.com/img/githubbutton_sm.svg]]
[[https://liberapay.com/trev.dev/donate][https://liberapay.com/assets/widgets/donate.svg]]
BTC: bc1qwad2jlteldw644w4wfh28y6ju53zfp69nnswrq
